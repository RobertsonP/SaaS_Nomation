import { Injectable, Logger } from '@nestjs/common';
import { Ollama } from 'ollama';
import { DetectedElement } from './interfaces/element.interface';

export interface ElementGroup {
  id: string;
  name: string;
  category: 'header' | 'footer' | 'navigation' | 'form' | 'content' | 'sidebar';
  elements: DetectedElement[];
  isCommon: boolean; // Appears on multiple URLs
  confidence: number;
}

export interface TestSuggestion {
  id: string;
  description: string;
  steps: Array<{
    type: string;
    elementId: string;
    description: string;
  }>;
  confidence: number;
}

@Injectable()
export class OllamaService {
  private readonly logger = new Logger(OllamaService.name);
  private ollama: Ollama;

  constructor() {
    this.ollama = new Ollama({
      host: process.env.OLLAMA_HOST || 'http://localhost:11434'
    });
  }

  async analyzePageElements(html: string, url: string): Promise<DetectedElement[]> {
    try {
      this.logger.log(`Analyzing page elements for ${url}`);
      
      const prompt = this.buildElementAnalysisPrompt(html, url);
      
      const response = await this.ollama.chat({
        model: 'llama3.2:latest',
        messages: [
          {
            role: 'user',
            content: prompt
          }
        ],
        format: 'json',
        options: {
          temperature: 0.1, // Low temperature for consistent results
          top_p: 0.9,
        }
      });

      const result = JSON.parse(response.message.content);
      
      if (result.elements && Array.isArray(result.elements)) {
        this.logger.log(`Found ${result.elements.length} elements via Ollama`);
        return result.elements.map(element => this.validateAndCleanElement(element));
      }
      
      this.logger.warn('No elements found in Ollama response');
      return [];
      
    } catch (error) {
      this.logger.error(`Ollama analysis failed: ${error.message}`);
      // Fallback to rule-based analysis
      return this.fallbackRuleBasedAnalysis(html);
    }
  }

  async groupSimilarElements(elements: DetectedElement[]): Promise<ElementGroup[]> {
    try {
      this.logger.log(`Grouping ${elements.length} elements`);
      
      const prompt = this.buildElementGroupingPrompt(elements);
      
      const response = await this.ollama.chat({
        model: 'llama3.2:latest',
        messages: [
          {
            role: 'user',
            content: prompt
          }
        ],
        format: 'json',
        options: {
          temperature: 0.1,
        }
      });

      const result = JSON.parse(response.message.content);
      
      if (result.groups && Array.isArray(result.groups)) {
        this.logger.log(`Created ${result.groups.length} element groups`);
        return result.groups;
      }
      
      return this.fallbackGrouping(elements);
      
    } catch (error) {
      this.logger.error(`Element grouping failed: ${error.message}`);
      return this.fallbackGrouping(elements);
    }
  }

  async categorizeElement(element: DetectedElement): Promise<string> {
    try {
      const prompt = `
        Analyze this web element and categorize it into one of these categories:
        - header: Navigation, logo, top menu elements
        - footer: Bottom page elements, copyright, links
        - navigation: Menu items, breadcrumbs, tabs
        - form: Input fields, buttons, form controls
        - content: Main page content, text, images
        - sidebar: Side navigation, filters, secondary content

        Element details:
        - Type: ${element.elementType}
        - Description: ${element.description}
        - Selector: ${element.selector}
        - Attributes: ${JSON.stringify(element.attributes)}

        Respond with just the category name: header, footer, navigation, form, content, or sidebar
      `;

      const response = await this.ollama.chat({
        model: 'llama3.2:latest',
        messages: [
          {
            role: 'user',
            content: prompt
          }
        ],
        options: {
          temperature: 0.1,
        }
      });

      const category = response.message.content.trim().toLowerCase();
      
      if (['header', 'footer', 'navigation', 'form', 'content', 'sidebar'].includes(category)) {
        return category;
      }
      
      return this.fallbackCategorization(element);
      
    } catch (error) {
      this.logger.error(`Element categorization failed: ${error.message}`);
      return this.fallbackCategorization(element);
    }
  }

  async generateTestSuggestions(elements: DetectedElement[]): Promise<TestSuggestion[]> {
    try {
      this.logger.log(`Generating test suggestions for ${elements.length} elements`);
      
      const prompt = this.buildTestSuggestionPrompt(elements);
      
      const response = await this.ollama.chat({
        model: 'llama3.2:latest',
        messages: [
          {
            role: 'user',
            content: prompt
          }
        ],
        format: 'json',
        options: {
          temperature: 0.3, // Slightly higher for creative test ideas
        }
      });

      const result = JSON.parse(response.message.content);
      
      if (result.testSuggestions && Array.isArray(result.testSuggestions)) {
        this.logger.log(`Generated ${result.testSuggestions.length} test suggestions`);
        return result.testSuggestions;
      }
      
      return this.fallbackTestSuggestions(elements);
      
    } catch (error) {
      this.logger.error(`Test suggestion generation failed: ${error.message}`);
      return this.fallbackTestSuggestions(elements);
    }
  }

  private buildElementAnalysisPrompt(html: string, url: string): string {
    return `
      You are an expert at analyzing web pages for test automation. Analyze this HTML and extract interactive elements that would be useful for automated testing.

      URL: ${url}
      
      HTML Content (truncated to first 10000 chars):
      ${html.substring(0, 10000)}

      For each interactive element, provide:
      1. A reliable CSS selector (prefer data-testid, id, then class)
      2. Element type: button, input, link, form, navigation, text
      3. A clear description of what the element does
      4. Confidence score (0.0 to 1.0)
      5. Important attributes

      Focus on elements that are:
      - Interactive (clickable, fillable, submittable)
      - Have stable identifiers
      - Are commonly used in testing workflows
      
      Return valid JSON in this format:
      {
        "elements": [
          {
            "selector": "button[data-testid='submit-btn']",
            "elementType": "button",
            "description": "Submit form button",
            "confidence": 0.95,
            "attributes": {
              "role": "button",
              "text": "Submit",
              "data-testid": "submit-btn"
            }
          }
        ]
      }
    `;
  }

  private buildElementGroupingPrompt(elements: DetectedElement[]): string {
    return `
      Group these web elements into logical categories for test automation. Elements that serve similar purposes or appear in the same section should be grouped together.

      Elements to group:
      ${JSON.stringify(elements, null, 2)}

      Create groups with these categories: header, footer, navigation, form, content, sidebar

      Return valid JSON in this format:
      {
        "groups": [
          {
            "id": "header-group-1",
            "name": "Main Navigation",
            "category": "header",
            "elements": [list of element IDs that belong to this group],
            "isCommon": true,
            "confidence": 0.9
          }
        ]
      }
    `;
  }

  private buildTestSuggestionPrompt(elements: DetectedElement[]): string {
    return `
      Based on these web elements, suggest realistic test scenarios that a QA engineer would want to automate.

      Available elements:
      ${JSON.stringify(elements.map(e => ({ 
        id: e.selector, 
        type: e.elementType, 
        description: e.description 
      })), null, 2)}

      Generate test suggestions that:
      1. Use multiple elements in logical workflows
      2. Cover common user journeys (login, search, form submission, etc.)
      3. Are realistic and valuable for testing
      4. Include proper test steps in sequence

      Return valid JSON in this format:
      {
        "testSuggestions": [
          {
            "id": "login-flow-test",
            "description": "Complete user login workflow",
            "steps": [
              {
                "type": "navigate",
                "elementId": "",
                "description": "Navigate to login page"
              },
              {
                "type": "type",
                "elementId": "input[name='email']",
                "description": "Enter email address"
              }
            ],
            "confidence": 0.8
          }
        ]
      }
    `;
  }

  private validateAndCleanElement(element: any): DetectedElement {
    return {
      selector: element.selector || '',
      elementType: element.elementType || 'button',
      description: element.description || 'Web element',
      confidence: Math.min(Math.max(element.confidence || 0.5, 0), 1),
      attributes: element.attributes || {}
    };
  }

  private fallbackRuleBasedAnalysis(html: string): DetectedElement[] {
    const elements: DetectedElement[] = [];
    
    // Simple regex-based extraction as fallback
    const buttonRegex = /<button[^>]*>(.*?)<\/button>/gi;
    const inputRegex = /<input[^>]*>/gi;
    const linkRegex = /<a[^>]*href="[^"]*"[^>]*>(.*?)<\/a>/gi;
    
    let match;
    
    // Extract buttons
    while ((match = buttonRegex.exec(html)) !== null) {
      elements.push({
        selector: 'button',
        elementType: 'button',
        description: `Button: ${match[1].replace(/<[^>]*>/g, '').trim()}`,
        confidence: 0.6,
        attributes: { text: match[1].replace(/<[^>]*>/g, '').trim() }
      });
    }
    
    // Extract inputs
    while ((match = inputRegex.exec(html)) !== null) {
      const typeMatch = match[0].match(/type="([^"]*)"/);
      const nameMatch = match[0].match(/name="([^"]*)"/);
      const type = typeMatch ? typeMatch[1] : 'text';
      const name = nameMatch ? nameMatch[1] : 'input';
      
      elements.push({
        selector: name ? `input[name="${name}"]` : 'input',
        elementType: 'input',
        description: `${type} input field${name ? ` (${name})` : ''}`,
        confidence: 0.7,
        attributes: { type, name }
      });
    }
    
    this.logger.log(`Fallback analysis found ${elements.length} elements`);
    return elements.slice(0, 20); // Limit to first 20 elements
  }

  private fallbackGrouping(elements: DetectedElement[]): ElementGroup[] {
    const groups: ElementGroup[] = [];
    
    // Group by element type
    const buttonElements = elements.filter(e => e.elementType === 'button');
    const inputElements = elements.filter(e => e.elementType === 'input');
    const linkElements = elements.filter(e => e.elementType === 'link');
    
    if (buttonElements.length > 0) {
      groups.push({
        id: 'buttons-group',
        name: 'Action Buttons',
        category: 'content',
        elements: buttonElements,
        isCommon: false,
        confidence: 0.7
      });
    }
    
    if (inputElements.length > 0) {
      groups.push({
        id: 'inputs-group',
        name: 'Form Inputs',
        category: 'form',
        elements: inputElements,
        isCommon: false,
        confidence: 0.8
      });
    }
    
    if (linkElements.length > 0) {
      groups.push({
        id: 'links-group',
        name: 'Navigation Links',
        category: 'navigation',
        elements: linkElements,
        isCommon: true,
        confidence: 0.6
      });
    }
    
    return groups;
  }

  private fallbackCategorization(element: DetectedElement): string {
    if (element.elementType === 'input') return 'form';
    if (element.elementType === 'button') return 'content';
    if (element.elementType === 'link') return 'navigation';
    if (element.elementType === 'form') return 'form';
    return 'content';
  }

  private fallbackTestSuggestions(elements: DetectedElement[]): TestSuggestion[] {
    const suggestions: TestSuggestion[] = [];
    
    const forms = elements.filter(e => e.elementType === 'form' || 
      (e.elementType === 'input' && e.attributes?.type !== 'hidden'));
    const buttons = elements.filter(e => e.elementType === 'button');
    const links = elements.filter(e => e.elementType === 'link');
    
    if (forms.length > 0 && buttons.length > 0) {
      suggestions.push({
        id: 'form-submission-test',
        description: 'Form submission workflow',
        steps: [
          { type: 'type', elementId: forms[0].selector, description: 'Fill form field' },
          { type: 'click', elementId: buttons[0].selector, description: 'Submit form' }
        ],
        confidence: 0.7
      });
    }
    
    if (links.length > 0) {
      suggestions.push({
        id: 'navigation-test',
        description: 'Basic navigation test',
        steps: [
          { type: 'click', elementId: links[0].selector, description: 'Navigate to page' }
        ],
        confidence: 0.6
      });
    }
    
    return suggestions;
  }
}